// Dart script to generate app_translations_data.dart from an Excel file.
// Expected Excel format: First row contains headers: key | en | de (case-insensitive).
// Subsequent rows contain translation entries.
// Usage: dart run tool/generate_translations.dart

import 'dart:io';

import 'package:excel/excel.dart';

void main(List<String> args) async {
  final projectRoot = Directory.current.path;
  final excelPath =
      '$projectRoot/english_german_translations.xlsx'; // Absolute provided path also works
  final outputPath = '$projectRoot/lib/core/utils/app_translations_data.dart';

  final file = File(excelPath);
  if (!await file.exists()) {
    stderr.writeln('Excel file not found at: $excelPath');
    exit(1);
  }

  final bytes = await file.readAsBytes();
  final excel = Excel.decodeBytes(bytes);

  if (excel.tables.isEmpty) {
    stderr.writeln('No sheets found in the Excel file.');
    exit(1);
  }

  final sheet = excel.tables[excel.tables.keys.first]!;
  if (sheet.maxRows < 2) {
    stderr.writeln(
      'Excel sheet must have a header row and at least one data row.',
    );
    exit(1);
  }

  // Read header
  final headerRow = sheet.rows.first;
  final headers = headerRow
      .map((c) => (c?.value?.toString() ?? '').trim().toLowerCase())
      .toList();

  int keyIdx = _findHeaderIndex(headers, ['key']);
  int enIdx = _findHeaderIndex(headers, [
    'en',
    'english',
    'eng',
    'en_us',
    'en-us',
  ]);
  int deIdx = _findHeaderIndex(headers, ['de', 'german', 'de_de', 'de-de']);

  // If there's no explicit key column but English exists, derive keys from English text
  bool deriveKeysFromEnglish = false;
  if (keyIdx == -1 && enIdx != -1) {
    keyIdx = enIdx;
    deriveKeysFromEnglish = true;
  }
  if (keyIdx == -1 || enIdx == -1 || deIdx == -1) {
    stderr.writeln(
      'Header must include columns for key and languages (e.g., key | en | de), or at least English and German. Found: ' +
          headers.join(', '),
    );
    exit(1);
  }

  final Map<String, String> enMap = {};
  final Map<String, String> deMap = {};

  for (int r = 1; r < sheet.maxRows; r++) {
    final row = sheet.rows[r];
    String key = _cellText(row, keyIdx);
    if (key.isEmpty) continue;
    String en = _cellText(row, enIdx);
    String de = _cellText(row, deIdx);

    if (deriveKeysFromEnglish) {
      key = _makeKeyFromEnglish(en);
    }

    enMap[key] = en;
    deMap[key] = de;
  }

  final buffer = StringBuffer();
  buffer.writeln('// Auto-generated translations data.');
  buffer.writeln(
    '// This file is generated by tool/generate_translations.dart from Excel.',
  );
  buffer.writeln('');
  buffer.writeln(
    'const Map<String, Map<String, String>> appTranslationsData = {',
  );
  buffer.writeln("  'en': {");
  enMap.forEach((k, v) {
    buffer.writeln("    '$k': ${_dartString(v)},");
  });
  buffer.writeln('  },');
  buffer.writeln("  'de': {");
  deMap.forEach((k, v) {
    buffer.writeln("    '$k': ${_dartString(v)},");
  });
  buffer.writeln('  },');
  buffer.writeln('};');

  await File(outputPath).writeAsString(buffer.toString());
  stdout.writeln('Generated translations to: $outputPath');
}

String _cellText(List<Data?> row, int idx) {
  if (idx < 0 || idx >= row.length) return '';
  final c = row[idx];
  final v = c?.value;
  if (v == null) return '';
  return v.toString().replaceAll('\r', '').trim();
}

String _dartString(String s) {
  // Escape single quotes and wrap in quotes
  final escaped = s.replaceAll("'", r"\'");
  return "'" + escaped + "'";
}

int _findHeaderIndex(List<String> headers, List<String> candidates) {
  for (int i = 0; i < headers.length; i++) {
    final h = headers[i];
    for (final c in candidates) {
      if (h == c || h.contains(c)) return i;
    }
  }
  return -1;
}

String _makeKeyFromEnglish(String en) {
  var s = en.toLowerCase();
  // Replace non-word characters with spaces
  s = s.replaceAll(RegExp(r"[^a-z0-9]+"), ' ');
  // Collapse spaces and join with underscores
  s = s.trim().replaceAll(RegExp(r"\s+"), '_');
  if (s.isEmpty) s = 'key_' + DateTime.now().millisecondsSinceEpoch.toString();
  return s;
}
